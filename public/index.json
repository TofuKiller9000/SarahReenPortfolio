[{"content":"","date":"29 December 2023","permalink":"/tags/on-going/","section":"Tags","summary":"","title":"on-going"},{"content":"","date":"29 December 2023","permalink":"/tags/programmer/","section":"Tags","summary":"","title":"Programmer"},{"content":"","date":"29 December 2023","permalink":"/projects/","section":"Projects","summary":"","title":"Projects"},{"content":"","date":"29 December 2023","permalink":"/","section":"Sarah Reen Portfolio","summary":"","title":"Sarah Reen Portfolio"},{"content":"Co-Director \u0026amp; Lead Programmer (August 2023 - current)\nSummary The future President of the United States needs your help! Help them learn the fundamentals of speaking and forming persuasive speeches that will move the hearts of millions. Work together as brain and body to complete puzzles and traverse levels.\nSpit It Out is a split-screne co-op puzzle game where you and a friend (or foe) play as a Brain and Body cell inside the body of the future President of the United States. Each player must navigate through their own unique level, each utilizing a set of Gizmos: color-coded tools that affect the other player\u0026rsquo;s level. The goal is to reach the end of each level, building up your speech skills with each passing level.\nStory Previous\rNextsads\rDevelopment Co-Op *Spit It Out* takes inspiration from classic 2 player co-op games such as *Portal 2*, *Lego Starwars*, and *It Takes Two*. Our team focused early on in development in creating the ideal co-op gameplay loop that rewarded both players. We set out these main goals early on: No player should be waiting on the other player for more than around 5 - 10 seconds Both players should be held equally accountable for their actions. No one player should be blamed for a mistake Both players must affect the other player\u0026rsquo;s gameplay to maintain co-op The gameplay loop must be simple to understand and fun to iterate upon We went through many different gameplay loop possibilities in trying to find something that held all four of these goals in the same regard. Eventually, we settled upon a \u0026rsquo;tic-for-tac\u0026rsquo; loop, with each player having their own unique Gizmos that are used to help the other player progress through their environment by placing down Gizmos on wires that had immediate effects depending on player input.\nGizmos and Gadgets After exploring and testing out several different gameplay loops to meet our criteria, we settled upon the final system of Gizmos and Gadgets: controllers and interactables that shape each player\u0026rsquo;s environment to help them progress through the level.\nEach player has two unique gizmos such as a Lever and Slider, or a Crank and a Button. These can be placed down on Wires that exist throughout the environment that are color coded to specific Gadgets in the other player\u0026rsquo;s section of the level. These gadgets might include something like a door, a seesaw, or a moving platform. Each player must use their limited number of Gizmos along with the variety of Gadgets in their environments to help one another traverse through obstacles.\nProgramming Gizmos and Gadgets When designing and implementing the systems for Spit It Out! I wanted to create a system that could be iterated upon and expanded without having to make significant changes to the foundation of the system. The Gizmo-Gadget Interaction system would have to account for 4 different interactable Gizmos (Lever, Button, Crank, and Slider), their unique input systems (Lever and Button are a single button input, but slider and crank require two), the Wire system (placing a Gizmo on a wire should only affect certain colored wires), along with a system to create new Gadgets that can do a wide plethora of things like opening doors, toggling something to be solid or transparent, and moving platforms. It was a multi-step, compltex task that required a bit of planning to determine the best way to tackle it.\nI created an Interface (represented by the dotted cube) for the Interaction system. An Interface is not an instantiable class, but rather, it is a collection of properties and methods that serve as a skeleton for classes to inherit from. Those classes are then required to implement those properties and methods. This is useful as it makes it so that we do not have to inherit from a class that has very little to do with what we really need and standardizes functionality across a set of systems.\nThis interface is then derived in our InteractableBase which sets and contains properties and methods such as the HoldDuration, whether or not an Object is Interactable, and whether it can be used multiple times. This interactable base is then placed on each of the objects that we wish to interact with, which is then referenced by the Interaction Controller the Player Character is utilizing. The InteractableBase also makes use of ScriptableObjects. We store our Gizmo Data in these scriptable objects which then gets fed to the Interaction Controller.\nThese Gizmos then call upon specific methods that relate to their category. The Lever and Button are boolean, either being in the Up or Down position, while the Crank and Slider are floats with every changing value in a range of 0 to 1. These state values are then fed to a set List of Gadgets given by the Wire the Gizmo is active upon. All Gadgets take in a value of 0 to 1, and perform different functions depending on that value. With this method, dozens of new Gizmos and Gadgets could be implemented into the game, and be compatible with other Gizmos and Gadgets.\nSplit Screen Co-Op The other major hurdle of Spit It Out! was implementing a Split Screen Co-Op system that kept track of the characters the players choose, attached those characters to the Controller IDs, and then keep that data throughout the entire game. Using the New Input System from Unity, I was able to create Input Controllers that are spawned in when the game first detects input from a controller. It then asks the player which character they want to play as, and then stores that information in a Game Instance that is not destroyed on load. This instance is then referenced throughout the entire game in correctly spawning in the player characters, and checking for input.\nGallery Don\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"29 December 2023","permalink":"/projects/spititout_project/","section":"Projects","summary":"Co-Director \u0026amp; Lead Programmer (August 2023 - current)","title":"Spit It Out!"},{"content":"","date":"29 December 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"Lead Programmer \u0026amp; Technical Artist (August 2023 - current)\nTrailer Summary Our Town is a single-player story-driven investigative horror game set in a small town in 1960\u0026rsquo;s America. You have just arrived in a new town to start working as a newspaper deliverer. However, this seemingly ordinary town holds dark secrets beneath its surface. Deliver newspapers, talk to your neighbors, and explore locations to find evidence and clues as to what is going on in this town.\nOur Town\u0026rsquo;s gameplay consists of day, evening, and night cycles. At the start of each day, players will be able to read the daily paper, which consists of 1960s popular trends and stories about the town. During the day players will deliver newspapers to residents and chat with them. During the evening players have free roam of the town to explore and interact, and at night players can stake out special discovered locations to find evidence of the town’s terrifying mystery. Using newfound evidence, you can then ask the residents about your findings and further the mystery.\nWhat do you discover through your investigation? What seems like the perfect 1960s American Suburb, is the home of an ancient cosmic entity who controls and feeds on the town’s residents. The entity, like an angler fish, has been using the town to lure people in. You have to find a way to save everyone! But remember; curiosity is not without its consequences. If you aren’t careful, you just might be the next missing person in the paper.\nDevelopment Programming Our Town is an ongoing project which currently has a live demo out. I am the Lead Programmer and Technial Designer for the project working in Unreal Engine 5. Some of the key systems I have created for the game include but are not limited to:\nBranching Dialogue Trees Dynamic Interaction System Physics-based Driveable Car Day-Night Cycle Multiple Endings My main goal was programming these systems was to create a solid foundation that could be interated upon and improved over time while also being easy to use for artists and developers without having to access complex code and blueprinting. This particularly came into play with the dialogue system.\nOur Town is heavily dialogue driven, and as such, we needed a system that could easily handle the myriad of different options. Additionally, the writers and artists would need to access this system regularly and be able to quickly understand and implement their dialogue, particularly when it changes. The current system utilizes UE5\u0026rsquo;s Behavior Tree System, along with custom Auxiliary Nodes that impact events based on the player\u0026rsquo;s choices. The advantage of this system is that it provides a visual flow for developers to see how the dialogue might look and feel while playing, while also being simplistic enough that is can be improved and expanded upon with additional custom nodes.\nAtmosphere and Environment Early on in development, we settled on a core aesthetic and themeing to the imagery of Our Town. We researched and utilized 1960\u0026rsquo;s Americana imagery of advertisements and pop culture, which was vital for our artists and writers to bring the Town to life. While exploring, the player might read the daily paper which will have references to what is going on at that time in history, and townsfolk will use appropriate lingo and make references to recent events. This helped tremendously in creating aspects of technical art such as developing appropriate shaders, lighting, and model animations.\nAll of these systems were created and tested based upon a pre-established Game Design Document which is being updated and changed as development continued.\nGallery Don\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"29 December 2023","permalink":"/projects/ourtown_project/","section":"Projects","summary":"Lead Programmer \u0026amp; Technical Artist (August 2023 - current)","title":"Our Town"},{"content":"","date":"29 November 2023","permalink":"/tags/devlogs/","section":"Tags","summary":"","title":"devlogs"},{"content":"","date":"29 November 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"29 November 2023","permalink":"/tags/programming/","section":"Tags","summary":"","title":"programming"},{"content":"","date":"29 November 2023","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"Programming This devlog cycle was partly broken up by Thanksgiving break, where I was barred from my family from doing work. So I wasn\u0026rsquo;t able to do as much as I normally would. But regardless, I was still able to accomplish some of the more urgent tasks. I continued squashing out bugs here and there where they popped up during playtesting, including but not limited to:\nReset Orientation when respawning Reset Momentum and Physics when respawning Prevented bug where player fell through the floor Box gets stuck in the wall when the player lets go of it Additionally, the major overhaul that I did was remaking the Radial Gizmo system to have a Split Canvas with the radial wheel always being available and seen. This fixed a couple of bugs with the radial menu not popping up and not being accessible in certain areas, while also being more convenient from a gameplay perspective. I also created a new system and set of animations to show the player when they are out of a certain gizmo.\nThis also involved creating the Limited Gizmo\u0026rsquo;s system, where players only have a max count of 1 per gizmo. When they place down a specific gizmo, they cannot place another of that type down until they remove it. In addition to this system, I also created a prefab that when the player passes through it, they will retain all of their previously spent gizmo, and the gadgets they were attached to will return to their original state.\nThis week I need to finalize the Tutorial System for the first level, along with more minor things like the Parallax background, Game Settings, and UI to better communicate to the player where they need to stand to interact with the Gizmos.\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"29 November 2023","permalink":"/posts/spititout_devlogs_week15_article/","section":"Posts","summary":"Programming This devlog cycle was partly broken up by Thanksgiving break, where I was barred from my family from doing work.","title":"Spit It Out - Week 15 Devlog"},{"content":"","date":"29 November 2023","permalink":"/series/spit-it-out-devlog/","section":"Series","summary":"","title":"Spit It Out Devlog"},{"content":"","date":"22 November 2023","permalink":"/tags/spit-it-out/","section":"Tags","summary":"","title":"spit it out"},{"content":"Bug Fixing \u0026amp; QA This week I continued work on fixing bugs such as:\nNot being able to prioritize picking up the weight on a button The player slides off into nothingness when they are moving and press the interact button Being unable to do a long jump on a platform that is rotated Redesigning the weight box (again) to fix the needs of the developer Fixed player being able to die repeatedly in an endless loop Reset the orientation of characters when respawning so that they do not have to complete the level at 90 degrees Orient gizmos to the wall\u0026rsquo;s rotation Programming In addition to this, I also continued work on implementing assets such as the Sprites for the Gizmos, along with attempting to implement graphics for the Parallax Background. The Backgrounds are not quite where we want them yet and require more tinkering. Additionally, I also created a death sprite animation event whenever the player falls onto a hazard. The sequence consists of the player exploding into chunks, the camera holding on to it for a few moments with an audio blip playing, and then the player respawning and the camera reattaching itself to them. I feel that this adds to the comedic effect the game is playing with the co-op since everyone loves to kill their friends in co-op games.\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"22 November 2023","permalink":"/posts/spititout_devlogs_week14_article/","section":"Posts","summary":"Bug Fixing \u0026amp; QA This week I continued work on fixing bugs such as:","title":"Spit It Out - Week 14 Devlog"},{"content":"Programming During this devlog cycle, I began the (rather fun) process of implementing sprites and animations for the player characters, along with the new radial UI for selecting gizmos. This involves taking the sprite sheets that were made by others and importing them into unity to create Animation Controllers for each character. Controllers are Unity\u0026rsquo;s way of containing a set of animations and then allowing you to transition from those animations based on a set of criteria that you can toggle in your scripting. Things like the Idle animation only playing when the player\u0026rsquo;s velocity is 0, or the Jump animation playing when it detects a successful jump have been requested.\nIn addition to this, I also implemented the radial menu animations and controls. The new system will pop up when the player is within interact distance of a wire. Tapping the Right Shoulder button will move the menu between their different gizmos along with the remove button. I also implemented Assets and Animations for various other things such as the Main Menu, Level Select, Jump Particles, Explosion Particles, and a few other minor things.\nBug Fixing \u0026amp; QA The other main thing I focused on was Bug Fixing along with a few minor feature Updates. This includes things such as removing the old radial menu, being unable to jump while on the seesaw, weight objects not respawning when the player dies, weights moving as though possessed when picked up or dropped, adding basic particle effects for certain events, prioritizing the weight when picking it up off of the button, wall jumping being possible, and the player being able to double jump\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"15 November 2023","permalink":"/posts/spititout_devlogs_week13_article/","section":"Posts","summary":"Programming During this devlog cycle, I began the (rather fun) process of implementing sprites and animations for the player characters, along with the new radial UI for selecting gizmos.","title":"Spit It Out - Week 13 Devlog"},{"content":"Bug Fixing \u0026amp; QA For this devlog cycle, the vast majority of my time was spent putting out fires in the form of bug fixing and major feature tweaking to better suit the level designers to have a build of the game ready. Some of the larger bug fixes included making sure players could not phase through platforms, could jump on seesaws, and numerous physics-related issues. I also provided tech support for things such as helping the level designers test their levels and implement various gadgets and gizmos.\nProgramming I also created a couple of new features such as being able to pick up weighted blocks and put them back down, new procedural animations for the Gadgets, and a Level Manager that will send the player back to the Main Menu once they have reached the end of the level.\nFor the next dev cycle, I will be working extremely hard on adding the remaining few features we need such as a water level system, along with smaller systems that I feel truly improve the overall design of the game. This includes things like a death animation, various particle effects, scene transitions, and a better Gizmo Selection UI that is based in the world as opposed to the canvas. I will of course be galavantly leading the charge against the bug infestation that will arrive in due time and will be sworn to vanquish as many as I can in my dying breath.\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"8 November 2023","permalink":"/posts/spititout_devlogs_week12_article/","section":"Posts","summary":"Bug Fixing \u0026amp; QA For this devlog cycle, the vast majority of my time was spent putting out fires in the form of bug fixing and major feature tweaking to better suit the level designers to have a build of the game ready.","title":"Spit It Out - Week 12 Devlog"},{"content":"Programming This week I focused my attention mostly on getting Two Player Co-Op working with Split Screen. While initially, this might not seem too complicated, it most certainly proved itself otherwise. This comes down to the way Unity\u0026rsquo;s New Input System handles spawning players and connecting those players to specific characters.\nTo control a character with a specific device, you need something called a Player Input Component. Normally when not working with co-op, if you were to plug in a compatible controller to your game, Unity would handle this on its own in the backend by searching for the Player Input Component in the scene and then pairing it with the device it has listed. This is simple enough, but problems arise when you have multiple controllers of the same type. How does Unity know which Controller to pair to each Player Input Component? It doesn\u0026rsquo;t.\nThe way that Unity gets around this is with the Player Input Manager Component, which spawns in Set Prefabs that have the Player Input Component on them when it detects input from a viable controller. Unity handles the pairing of devices to Player Inputs on its own, which on one hand is nice, but on the other can be rather frustrating when you want to specify it yourself. Additionally, these pairings do not carry over from scene to scene, and with the way that Unity handles Split Screen currently, nothing would be displayed on the screen until a Player Input is spawned.\nMy job was to figure out how to have the players\nspawn themselves in Store the data of the controllers and the control schemes for each player Have the players select which character they want to play as Carry that information over into the next scene. This took quite a bit of time, and I encountered numerous bugs in attempting to find the solution such as multiple players being spawned, the split screen only showing one player, and the players not spawning at the correct spawn points determined by the developers.\nIn the current system, it works quite nicely, though I have some concerns about how I will continue this implementation after the players have finished the level and return to the Level Select screen.\nBug Fixing \u0026amp; QA In addition to this, I also tackled and solved numerous bugs. Some examples include:\nFix Slider, Crank, and Button not acting properly with Gadgets Fixed Gadgets not returning to their original state when the Gizmo is removed Fixed a small bug of interacting with a Value Change Gizmo not always registering Fixed a bug of a Player being able to put down a gizmo without being near a wire Fixed a bug of the player being able to move while interacting with a gizmo Fixed rotating and slider values being shared among players My current task involves setting the Respawn system up so that it works for the Co-Op controllers. While my respawn system works for a single player, I have encountered some bugs with making it work for Co-Op players. I\u0026rsquo;m hoping to have this fixed by the end of the day.\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"1 November 2023","permalink":"/posts/spititout_devlogs_week11_article/","section":"Posts","summary":"Programming This week I focused my attention mostly on getting Two Player Co-Op working with Split Screen.","title":"Spit It Out - Week 11 Devlog"},{"content":"Programming During this devlog cycle, I focused on trying to get the 2 Player Co-op systems working properly, along with setting things up for the Level Designers to begin testing things out.\nI am using Unity\u0026rsquo;s New Input System for Player Controls. So far it has worked perfectly with single-player, and even just spawning in two characters that are tied to two controllers works. The issue comes in having players select which character they want to play as and then carrying that information over to the next scene with pre-spawned in-player characters. The way that Unity handles identifying controllers is through a component called Player Input. If a player Input is spawned, it ALWAYS has to have an input device connected with it. So while in one scene I can have two-player inputs spawned in contained to two different controllers, I\u0026rsquo;m having a tough time figuring out the best way to carry those inputs into the next scene. This is still a work in progress, and I\u0026rsquo;m hoping to get more headway with this before next Monday.\nI also created a video showcasing to the level designers how to start setting up and testing levels. It is a bit jank at the moment due to the problems with spawning in players, but it works for now. I also encountered a couple of bugs with some of the gizmos that I need to iron out once I get the Player Controls working.\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"25 October 2023","permalink":"/posts/spititout_devlogs_week10_article/","section":"Posts","summary":"Programming During this devlog cycle, I focused on trying to get the 2 Player Co-op systems working properly, along with setting things up for the Level Designers to begin testing things out.","title":"Spit It Out - Week 10 Devlog"},{"content":"Programming I continued my work on implementing the Interaction System which will be vital in implementing the various gizmos and \u0026ldquo;gadgets.\u0026rdquo; gizmos refer to the 4 main objects the two players will be interacting with (Lever, Button, Crank, Slider), and Gadgets refer to the objects that are affected by those gizmos (Door, Laser, Air Turbine, etc.) When a player interacts with a gizmo, it needs to do two main things:\nRetrieve data about the specific gizmo the player has interacted with and update the value of it. Retrieve data about the specific gadget the gizmo will be affecting and update it with the given value from the gizmo. All gizmo objects inherit from a base Parent known as InteractableBase. This class sets up the needed functions for what is required in Step 1. It sets up an interaction event and then updates its value based on that specific interaction event. It then calls another function that Updates the specific gadget.\nHowever, we will have several different types of gizmos that all have unique attributes and characteristics. It would be better to place that logic in its separate script that inherits from InteractableBase. This keeps our code clean and organized, without running the risk of certain objects having access to things they shouldn\u0026rsquo;t have. For example, in the Lever Script, it can update its value to either 0 or 1; the only two values that it can have are reflected by the Up or Down state. But in comparison, the Crank Script updates its value between a range of 0 to 1 based on the position of its child object in a 360-degree rotation.\nWe then need to retrieve data about the specific gadget that we want to update given the value of the gizmo. This is done similarly to how we retrieve the gizmo: with scriptable Object. When interacting with an object, the InteractionBase searches for the gizmo data of the given object. It then populates itself with that data to perform certain functions successfully. The InteractionBase will also then have to search for the relevant gadget data based on several properties such as which wire the gizmo is attached to, and what gadget is also attached to that wire. This part of the script is still a work in progress.\nCurrently, the lever gizmo and door gadget are working as intended, but more work needs to be done with the Crank. Since the Button and Slider are simply slightly different versions of the Lever and Crank, they will not take nearly as long to develop once the previous two are finished. I\u0026rsquo;m hoping to have all of this done before the 50% Sprint.\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"21 October 2023","permalink":"/posts/spititout_devlogs_week8_article/","section":"Posts","summary":"Programming I continued my work on implementing the Interaction System which will be vital in implementing the various gizmos and \u0026ldquo;gadgets.","title":"Spit It Out - Week 8 Devlog"},{"content":"Programming For week 9 I finalized the systems for all the Gizmos (Crank, Slider, Button, and Lever), along with the wire system, and created some of the basic Gadgets that the Level Designers will need for the first level.\nLast week, I created the Lever and the Crank system. To be able to fully test out these Gizmos, along with incorporating them into the Wire System, I would need some sort of simple interface that allows me to choose and spawn in Gizmos. I created a radial menu that shows up when the player holds down the North D-pad key on their respective controller. Using the Right joystick, they can swivel around the different choices with a visual indicating which Gizmo they are on. The player then has to hit the North button on their gamepad to select the gizmo. That gizmo will now spawn when the player interacts with a Wire. This UI is simply a placeholder, along with the controls associated with it. I just needed something quick and easy that could be changed in the future.\nThe Wire System inherits from the same InteractionBase that the Gizmos inherit from, but it also inherits from its own Class called Wire. Its data is stored in a WireData ScriptableObject similar to how the GizmoData is stored. When the player walks up to a Wire, it will grab that Wire data and check if it has a Gizmo attached to it. If it does not, then it enters into a state where the player can interact with the Wire and spawn in their selected Gizmo. Doing so will change the state of the Wire to Attached, and it will grab the data of the Gizmo that it is attached to. The Wire is no longer interactable.\nThe wire stores a list of all the Gadgets that it affects. This List has to be manually set by the Developer in the Inspector. All Items stored in that List MUST have a gadget base or it will reject the Object. Once the Wire exits its interactable state, it then passes that list of Gadgets to the attached Gizmo. That attached gizmo then uses that list to update the value/state of the respective Gadgets.\nAll gizmos output a value between 0 - 1. This is extremely useful as it standardizes all the Gadgets to have to take an input between 0 - 1 and use that information to update their states/values. Gizmos fall under two categories: state change and value change. State Change Gizmos are Gizmos that swap immediately from 0 to 1 or 1 to 0. Gizmos like the lever or the button fall under this category. Value Change Gizmos are Gizmos that have a gradation of values from 0 to 1 and can float between them at the player\u0026rsquo;s own input. These correspond to Gizmos like the crank or slider. All gadgets have specific functions that correspond to either a State change or a value change depending on the gizmo.\nI plan to record a video going over the different GameObjects + Prefabs and how the Level Designer would use them to create their levels. This would include showing them how to set up their own Wires and Gadgets and how to link them up together. That will be posted on the Devlogs once that is up.\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"18 October 2023","permalink":"/posts/spititout_devlogs_week9_article/","section":"Posts","summary":"Programming For week 9 I finalized the systems for all the Gizmos (Crank, Slider, Button, and Lever), along with the wire system, and created some of the basic Gadgets that the Level Designers will need for the first level.","title":"Spit It Out - Week 9 Devlog"},{"content":"Programming This week I began work on what will most likely be the most complicated system in our game, the Gizmo system. The Gizmo system encompasses all of the 4 different interactable gizmos (Lever, Button, Crank, and Slider), their unique input systems, the Wire system (gizmos only affect certain colored wires), along with the necessary Interaction Controller System for the player to be able to interact with them in the first place. It is a multi-step, complex task that has thus far required quite a bit of planning on my end to determine the best way to do this.\nThe first thing to tackle was the Interaction system itself. I could need to create a system that had a solid base that could be implemented into various classes that could encompass things potentially outside of the gizmos (e.g. keys, collectibles).\nI created an Interface (represented by the dotted cube) for the Interaction system. An Interface is not an instantiable class, but rather, it is a collection of properties and methods that serve as a skeleton for classes to inherit from. Those classes are then required to implement those properties and methods. This is useful as it makes it so that we do not have to inherit from a class that has very little to do with what we really need and standardizes functionality across a set of systems.\nThis interface is then derived in our InteractableBase which sets and contains properties and methods such as the HoldDuration, whether or not an Object is Interactable, and whether it can be used multiple times. This interactable base is then placed on each of the Objects that we wish to interact with, which is then referenced by the Interaction Controller the Player Character is utilizing. The InteractableBase also makes use of ScriptableObjects: a data container that allows us to save data independent of class instances. We store our Gizmo Data in these scriptable objects which then gets fed to the Interaction Controller.\nThese Gizmos then call upon specific methods that relate to their category. The Lever and Button are boolean, either being in the Up or Down position, while the Crank and Slider are floats with every changing value in a range.\nThe Interface, Gizmo Data, and Interaction Base are all complete, but the Interaction controller currently only has pseudo-code and needs to be fully implemented and tested.\nFinally, in order for functionality in the Interaction Controller to be correct, I updated the Player Input Controller to change the direction of the Sprite Depending on which way the character is moving.\nThe Input Controller now has two new boolean values: Spawn Facing Left \u0026amp; Spawn Facing Right. Depending on which boolean is triggered, the Player will spawn either facing the left direction or the right direction. The Scale.x value of the player is then swapped between -1 and 1 depending on which direction they are moving. Ideally, these should be set in the future Level Controller script, but works fine here for now.\nThis week I will continue implementing the Interaction and Gizmo system, and will hopefully have the entire system complete by the end of the week.\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"4 October 2023","permalink":"/posts/spititout_devlogs_week7_article/","section":"Posts","summary":"Programming This week I began work on what will most likely be the most complicated system in our game, the Gizmo system.","title":"Spit It Out - Week 7 Devlog"},{"content":"Game Design Working with Grayson and William, we went through many different iterations of what the gameplay loop would be between the two players. The main concern was ensuring that each player had equal footing and responsibility in their goals and duties, while also ensuring that no player would be waiting on the other player for an extended period. We went back and forth on a few different ideas, but this usually resulted in either the \u0026lsquo;Brain\u0026rsquo; or the \u0026lsquo;Body\u0026rsquo; having more interesting things to do, but not both simultaneously. In coming up with a new gameplay loop, we set out these main goals:\nNo player should be waiting on the other player for more than around 5 - 10 seconds Both players should be held equally accountable for their actions. No one player should be blamed for a mistake Both players must affect the other player\u0026rsquo;s gameplay to maintain co-op The gameplay loop must be simple to understand and fun to iterate upon After more brainstorming, Grayson and I came up with a new gameplay loop. Using the Gizmos (Lever, Crank, Button, Slider) from previous iterations, we create a system where each player would be able to control their own Gizmos. Both the Brain and the Body would be traversing through their own puzzle platformer but would require the other player to perform certain actions on their side to continue forward. Each player would have Wires on their side of the level which would be color-coordinated to match to various elements of either their level or the other player\u0026rsquo;s level (A purple wire would do something to the purple door). The main gameplay loop comes from placing Gizmos on these Wires, figuring out what effect these cause, and then coordinating with one another to traverse through the level.\nThis solves all of the aforementioned goals that we were struggling with. It makes the coordination feel more like a two-sided conversation, with each person contributing their own logic and abilities to solving the puzzle, without one person doing all the work. Both players are held equally accountable since they have their own unique tasks, both are affecting the other player\u0026rsquo;s gameplay and are doing so in a fun loop that (while perhaps difficult for our level designers) can be iterated upon in future levels.\nProgramming For this project we are using Unity (2022.3.0f1), due to this engine being the most familiar to the group and because Unity allows for very quick prototyping which is essential in the early stages. For this week, after setting the project up on Perforce, I began work on creating the basic Player Controller. From the start, I wrote down a few different goals I wanted to have for this player controller.\nPC Feels good to move Includes a Jump Buffer Includes Coyote Time Variable Jump Height Variable Attributes that can be tested and tweaked by the Editor I researched other 2D Platforms such as Celete, Super Meat Boy, and a few others to get a good sense of why their controls feel so good to play, and from that came the aforementioned goals.\nI am using the New Input System from Unity for this project, allowing me to have multiple different controllers whether that be a Keyboard, Gamepad, or a combination of the two.\nThis was then set up with Custom Unity Events in a Player Input Script to allow for Jumping and basic movement. The Player Controller uses a Rigidbody2D, along with a Box Collider and Edge Collider. This allows me to be able to specify variables such as Gravity Modifiers, Max Velocity, and Friction.\nWith this, I was able to set Serializable Variables in the Inspector for outside developers to mess with to find the right feel for the Characters.\nJump Height indicates the highest a character can jump Max Air Jump allows players to redirect themselves better while in the air (Also serves as a double jump if necessary) Downward Movement Multiplier is the gravity modifier used when the player is making a descent Upward Movement Multiplier is the gravity modifier used when the player is actively jumping Coyote Time refers to allowing the player to still access the Jump action a few seconds after they have left the Ground. Jump Buffer Time refers to the action of Queuing up a Jump action if a player has requested it a few seconds before being officially on the ground. With this, the Basics of the Player Controller involving Movement and Jumping are complete. Of course, iteration and improvements will continue to happen throughout development, but this will provide us with an excellent starting point to move development forward for testing.\nSplit Screen, along with an improved 2 Player Management System will be forthcoming. Next Sprint will involve creating and implementing the Gizmo System.\nDon\u0026rsquo;t forget to check out our demo on Itchio.\r","date":"27 September 2023","permalink":"/posts/spititout_devlogs_week6_article/","section":"Posts","summary":"Game Design Working with Grayson and William, we went through many different iterations of what the gameplay loop would be between the two players.","title":"Spit It Out - Week 6 Devlog"},{"content":"Level Designer (March 2023 - May 2023)\nLevel Sequence Summary Canyon Treasure is a level concept for a 3D action adventure open-world game where you play as a Treasure Hunter seeking the riches buried in the sands of the caves. Be warned! Bandits guard the entrances to these hidden treasure troves so you must be on your guard, and who knows what lurks in the deepest parts of the cave.\nThis project was completed in two parts over several months: the linear dungeon level, and then combining that with the open world level. I really wanted to focus on using color, along with the environment, to push the player along naturally. There are multiple landmarks, and \u0026ldquo;a-ha!\u0026rdquo; moments throughout the level that reward player for their exploration, while also naturally guiding them to their next objective.\nDevelopment Level Design When I began work on the outside environment space, I sketched out the general flow and space proportions. I wanted a central area to draw the player in to serve as a hub world, and then to be naturally guided to the castle ruins.\nMy goal for this project was to combine an open-world map that lead into a more linear dungeon. The initial starting area is wide and vast, with warm oranges and yellows for a comforting feel. Ancient statues that have been buried by the sands of time act as a landmark for players to lead them to the local Marketplace. Here, players could trade, buy, sell, and accept quests from NPCs.\nThe environment then naturally guides the player towards their destination with the opening of the canyon, and the landmarks of the bandit camp at the throat of it. The player has different options for how they might want to deal with the bandits, taking a more stealthy approaching by coming around from the back by a visible path, or using the bandits\u0026rsquo; own traversal tools of ladders, ropes, and pulley systems.\nAfter passing through the castle ruins in the canyon, the player would navigate to a secret cave holder vast treasures. The initial closed-off cave corridors force the player to feel more confined and to focus on their surroundings. They would have to solve a puzzle involving a mysterious rune on the far wall. Solving this, the player is rewarded visually with the grand focal point of the level, where players would then take part in a Raid-like encounter with a boss.\nGallery ","date":"1 May 2023","permalink":"/projects/canyontreasure_project/","section":"Projects","summary":"Level Designer (March 2023 - May 2023)","title":"Canyon Treasure"},{"content":"","date":"1 May 2023","permalink":"/tags/level-designer/","section":"Tags","summary":"","title":"Level Designer"},{"content":"Solo Developer (March 2022 - April 2022)\nTrailer Summary You are a young girl on her way to her grandmother\u0026rsquo;s. Shouldn’t take too long, right?\nPlay as little red riding hood, trekking through woods, oceans, caves, dungeons, and mountains to get to grandma’s house. Watch out for strange creatures that block your way. Pick up pieces of the story to continue forward! Along the way, collect items to give to Grandma like bread, wine, and jam! There are five hidden on each level, can you find them all?\nA Short Walk to Grandma\u0026rsquo;s is a 2D platformer where you play as little red riding hood, traversing through four levels to reach your Grandma. Little Red is equipped with her trusty bow and her double jump to traverse through the dangerous jungle, coastline, castle, and forest while enemies attack you. Each level the player must find the next page to the story, along with potential collectibles hidden in each level. This game was made over the course of 1 Month and was submitted to Horizons Showcase 2022 along with being presented at GDEX 2022.\nDevelopment Level Design While I was the solo-developer for this game, I used this game as a chance to improve my Level Design skills. The game consists of 4 levels, with a variety of enemies specific to each level being presented slowly to the player for them to test their new abiliites.\nThe first level, The Jungle, focuses more on allowing the player to familiarize themselves with the playforming and double jump. While there are enemies, they are projecticle enemies, standing far off for the player to dodge their attacks and retaliate with their bow. Enemies are just far enough away for the bow\u0026rsquo;s arrows to hit, allowing the player to understand the distance their own attacks have.\nThe Coastline introduces melee enemies to the player with simplistic pathing, allowing the player to developer strategies about how to best avoid damage. It also increases the difficulty of the platforming, with more precise jumps now necessary.\nThe Castle is a labrythn the player must navigate to successfully find the next page. This level has more deadly melee enemies, along with environmental hazards such as spears, acid, and spike pits. The collectibles are more well hidden in secret areas and tunnels. One collectible is found in a obscured drop down tunnel that the player cannot fully access until later in the level, but it is hinted at by the placement of a skeleton enemy at the entrance.\nFinally, the Forest combines everything the player has experienced so far with a plethora of melee and projectile enemies, along with environmental hazards. Depending on the path the player takes, they might traverse through the thorny trees with hiding goblins, or jump above the trees with flying mosters.\nThe collectibles found throughout the levels encourage the player to search through each level to find secrets and succeed in platforming challenges.\nGallery Check out the game! on Itchio.\r","date":"17 April 2022","permalink":"/projects/ashortwalktg_project/","section":"Projects","summary":"Solo Developer (March 2022 - April 2022)","title":"A Short Walk to Grandma/'s"},{"content":"Level Designer (April 5th - April 12th, 2021)\nSummary Freedom Frogs is a 2D rhythm platformer where you play as a Prince turned into a frog by the magical witch of the forest. Traverse through the forest collecting all parts of the frogs\u0026rsquo; song to the beat of the ever changing music and hopefully you live to croak another day!\nI worked as the Lead Level Designer for this 2021 College Game Jam Submission. I worked remotely with 4 other people to design and implement the project in Unity. Out of 84 submissions, we placed 4th in the competition and received a prize for our efforts. The key element I followed in designing the levels for this project was creating sections where the player could test out and master each ability, and then a final section where they had to put it all together.\nLevel Design Early on I pitched the game mechanics of movement and abilities being tied to the beat of the music, and that the player would have to plan out their movement and attacks based on the changing beat.\nI created jumping sections in the level that have the player trying to navigate around enemies while also not falling in the water. However, if the player times their jump correctly, they can get an added bonus jump from jumping on top of the enemies. This is taught to the players early on with this fish level.\nAs the player continues the level, they unlock new abilities that are used on the off-beat and up-beat of the song. This includes a tongue ability, which is useful for linear movement enemies like these beetles. This section teaches that to the player.\nWhenever the player gains a new ability, I used that section of the level to teach the player how to use that ability. This culminates in the ending area which utilizes all three abilities to traverse.\nGameplay and Developers Talk Gallery Check out the game! on Itchio.\r","date":"12 April 2021","permalink":"/projects/freedomfrogs_project/","section":"Projects","summary":"Level Designer (April 5th - April 12th, 2021)","title":"Freedom Frogs"},{"content":"\rHeyo and welcome to my little corner of the internet! My name is Sarah and I am a Programmer 💻 and Level Designer 🎮 all wrapped up into one nerdy little ball, with a cat 🐱 on the side. I enjoy reading fantasy novels \u0026amp; playing tabletop games, my favorite bird is the Turkey Vulture, and I pronounced \u0026ldquo;ramen\u0026rdquo; 🍜 as \u0026ldquo;ray-man\u0026rdquo; until I was 17.\nEvery day I work hard to create beautiful things that bring joy, whether that be through code or pixels on the screen. I have diverse set of skills that have molded me into a flexible, self-motivating, team-player that is driven to succeed. Let\u0026rsquo;s make beautiful things together!\nCheck out my Resume or look through my Portfolio ✨\n","date":"1 January 0001","permalink":"/about/","section":"Sarah Reen Portfolio","summary":"Heyo and welcome to my little corner of the internet!","title":"About Me"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"}]